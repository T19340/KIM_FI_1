# =============================================================================
# 수동 설정 부분
# =============================================================================
working_directory = r"D:\채권\작업중"
source_file = "real_data1.xlsx"
output_prefix = "decrypted_"

# =============================================================================
# 자동 실행 부분 (수정 불필요)
# =============================================================================
import os
import win32com.client
from pathlib import Path
from datetime import datetime
import time
import pythoncom
import psutil
from openpyxl import Workbook

def clean_cell_value(value):
    """셀 값에서 타임존 정보 제거"""
    if isinstance(value, datetime):
        return value.replace(tzinfo=None)
    return value

def kill_excel_processes():
    """모든 Excel 프로세스 종료"""
    print("Excel 프로세스 정리 중...")
    
    killed_count = 0
    for proc in psutil.process_iter(['pid', 'name']):
        try:
            if proc.info['name'].upper() in ['EXCEL.EXE', 'WINWORD.EXE', 'POWERPNT.EXE']:
                proc.kill()
                killed_count += 1
                print(f"  {proc.info['name']} (PID: {proc.info['pid']}) 종료됨")
        except (psutil.NoSuchProcess, psutil.AccessDenied):
            pass
    
    if killed_count > 0:
        print(f"총 {killed_count}개 Office 프로세스 종료")
        time.sleep(3)
    else:
        print("실행 중인 Office 프로세스 없음")

def excel_drm_bypass_preserve_values(source_path, output_path):
    """결과값 보존 Excel DRM 우회 (함수는 제거, 값은 보존)"""
    print("결과값 보존 Excel 처리 시작...")
    
    # 1단계: Excel 프로세스 정리
    kill_excel_processes()
    
    # 2단계: 파일 접근 권한 확인
    try:
        with open(source_path, 'rb') as test_file:
            test_file.read(100)
        print("파일 접근 권한 확인됨")
    except Exception as access_error:
        print(f"파일 접근 오류: {access_error}")
        return False
    
    excel = None
    workbook = None
    
    try:
        # 3단계: COM 초기화 및 Excel 실행
        print("Excel COM 초기화...")
        pythoncom.CoInitializeEx(pythoncom.COINIT_APARTMENTTHREADED)
        
        excel = win32com.client.DispatchEx("Excel.Application")
        excel.Visible = False
        excel.DisplayAlerts = False
        excel.ScreenUpdating = False
        excel.EnableEvents = False
        
        # 외부 데이터 연결 알림 비활성화 (하지만 기존 값은 유지)
        excel.AskToUpdateLinks = False
        excel.AlertBeforeOverwriting = False
        
        print("Excel 애플리케이션 생성 성공")
        
        # 4단계: 파일 열기 (외부 연결 업데이트 안함, 기존 값 유지)
        print("파일 열기 중 (외부 연결 업데이트 안함)...")
        try:
            workbook = excel.Workbooks.Open(
                source_path,
                UpdateLinks=0,          # 외부 링크 업데이트 안함 (기존 값 유지)
                ReadOnly=True,          # 읽기 전용
                IgnoreReadOnlyRecommended=True
            )
            print("파일 열기 성공 (기존 계산값 유지)")
        except Exception as open_error:
            print(f"파일 열기 실패: {open_error}")
            raise
        
        # 5단계: 계산 모드를 수동으로 설정 (추가 계산 방지, 기존 값 유지)
        print("계산 모드 수동 설정 (기존 값 보존)...")
        try:
            excel.Calculation = -4135  # xlCalculationManual (새 계산 방지)
            excel.CalculateBeforeSave = False
            print("수동 계산 모드 설정 완료 - 기존 계산값 보존됨")
        except Exception as calc_error:
            print(f"계산 모드 설정 오류: {calc_error}")
        
        # 6단계: 워크시트 접근
        print("워크시트 정보 확인 중...")
        try:
            worksheet_count = workbook.Worksheets.Count
            print(f"워크시트 개수: {worksheet_count}")
            
            worksheet = workbook.Worksheets(1)
            print(f"워크시트 선택 성공: {worksheet.Name}")
        except Exception as ws_error:
            print(f"워크시트 선택 오류: {ws_error}")
            raise
        
        # 7단계: 사용된 범위 확인 (더 관대하게)
        print("사용된 범위 확인 중...")
        try:
            used_range = worksheet.UsedRange
            if used_range:
                rows = used_range.Rows.Count
                cols = used_range.Columns.Count
                print(f"사용된 범위: {rows}행 {cols}열")
            else:
                print("UsedRange가 None, 대체 방법 사용")
                # 대체 방법: 데이터가 있는 마지막 셀 찾기
                last_cell = worksheet.Cells.SpecialCells(11)  # xlCellTypeLastCell
                rows = last_cell.Row
                cols = last_cell.Column
                print(f"마지막 셀 기준 범위: {rows}행 {cols}열")
        except Exception as range_error:
            print(f"범위 확인 오류: {range_error}")
            # 기본값 사용
            rows = 1000
            cols = 50
            print(f"기본 범위 사용: {rows}행 {cols}열")
        
        # 8단계: 값 전체 추출 (Value 속성으로 한 번에)
        print("모든 계산값 한 번에 추출 시도...")
        cleaned_data = []
        
        try:
            # 전체 범위에서 Value 속성으로 한 번에 추출
            if 'used_range' in locals() and used_range:
                data_range = used_range.Value
            else:
                # UsedRange가 없으면 수동으로 범위 설정
                range_address = f"A1:{chr(64 + min(cols, 26))}{min(rows, 10000)}"
                manual_range = worksheet.Range(range_address)
                data_range = manual_range.Value
            
            print(f"데이터 추출 성공, 타입: {type(data_range)}")
            
            if data_range is not None:
                if isinstance(data_range, tuple):
                    # 다중 행 데이터
                    for row_data in data_range:
                        if isinstance(row_data, tuple):
                            cleaned_row = [clean_cell_value(cell) for cell in row_data]
                        else:
                            cleaned_row = [clean_cell_value(row_data)]
                        cleaned_data.append(cleaned_row)
                else:
                    # 단일 셀 데이터
                    cleaned_data = [[clean_cell_value(data_range)]]
                
                print(f"값 추출 완료: {len(cleaned_data)}행 (모든 계산값 보존)")
            else:
                raise Exception("데이터 추출 결과가 None")
                
        except Exception as value_error:
            print(f"전체 추출 실패: {value_error}")
            print("개별 셀 추출 시도...")
            
            # 개별 셀 추출 (폴백)
            cleaned_data = []
            for row in range(1, min(rows + 1, 5000)):
                row_data = []
                for col in range(1, min(cols + 1, 100)):
                    try:
                        cell = worksheet.Cells(row, col)
                        # 셀의 현재 표시값 가져오기 (함수 결과값 포함)
                        value = cell.Value
                        row_data.append(clean_cell_value(value))
                    except Exception as cell_error:
                        # 접근 불가능한 셀은 빈 값
                        row_data.append("")
                
                cleaned_data.append(row_data)
                
                # 진행 상황 표시
                if row % 100 == 0:
                    print(f"    {row}행 처리 완료...")
            
            print(f"개별 추출 완료: {len(cleaned_data)}행")
        
        # 9단계: Excel 종료
        print("Excel 종료 중...")
        try:
            workbook.Close(SaveChanges=False)
            workbook = None
            excel.Quit()
            excel = None
            pythoncom.CoUninitialize()
            print("Excel 정상 종료")
        except Exception as close_error:
            print(f"Excel 종료 중 오류: {close_error}")
        
        # 10단계: 새 파일 생성 (값만 저장, 함수는 제거됨)
        print("새 Excel 파일 생성 중 (값만 저장)...")
        wb = Workbook()
        ws = wb.active
        
        actual_data_rows = 0
        for row_idx, row_data in enumerate(cleaned_data, 1):
            has_data = False
            for col_idx, cell_value in enumerate(row_data, 1):
                try:
                    if cell_value is not None and str(cell_value).strip():
                        has_data = True
                    ws.cell(row=row_idx, column=col_idx, value=cell_value)
                except Exception:
                    ws.cell(row=row_idx, column=col_idx, value="")
            
            if has_data:
                actual_data_rows = row_idx
        
        wb.save(output_path)
        wb.close()
        
        print(f"Excel DRM 우회 완료 - {actual_data_rows}행의 계산값 보존됨")
        print("💡 모든 함수는 계산된 결과값으로 변환되었습니다")
        return True
        
    except Exception as main_error:
        print(f"처리 중 오류 발생: {main_error}")
        return False
        
    finally:
        # 리소스 정리
        try:
            if workbook:
                workbook.Close(SaveChanges=False)
        except:
            pass
        
        try:
            if excel:
                excel.Quit()
        except:
            pass
        
        try:
            pythoncom.CoUninitialize()
        except:
            pass

def main():
    """메인 실행 함수"""
    source_path = os.path.join(working_directory, source_file)
    
    file_path = Path(source_file)
    output_filename = f"{output_prefix}{file_path.name}"
    output_path = os.path.join(working_directory, output_filename)
    
    print("=" * 60)
    print("결과값 보존 Excel DRM 우회 툴")
    print("=" * 60)
    print("핵심 원리: 함수 제거 + 계산된 결과값 보존")
    print("=" * 60)
    
    if not os.path.exists(source_path):
        print(f"오류: 파일이 존재하지 않습니다: {source_path}")
        return
    
    file_size = os.path.getsize(source_path)
    print(f"원본 파일 크기: {file_size:,} bytes")
    
    start_time = time.time()
    
    if excel_drm_bypass_preserve_values(source_path, output_path):
        elapsed_time = time.time() - start_time
        print("-" * 50)
        print(f"✅ Excel DRM 우회 완료! (소요시간: {elapsed_time:.2f}초)")
        print(f"📁 저장 위치: {output_path}")
        
        if os.path.exists(output_path):
            output_size = os.path.getsize(output_path)
            print(f"📊 생성된 파일 크기: {output_size:,} bytes")
            print("📋 특징: 인포맥스 등 함수는 제거되었지만 계산된 값은 모두 보존됨")
    else:
        elapsed_time = time.time() - start_time
        print("-" * 50)
        print(f"❌ Excel DRM 우회 실패 (소요시간: {elapsed_time:.2f}초)")

if __name__ == "__main__":
    main()
